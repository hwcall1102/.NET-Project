@using Microsoft.EntityFrameworkCore
@using TakeawayTitans.Data
@using TakeawayTitans.Data.Models
@inject IDbContextFactory<TakeawayTitansContext> DbFactory
<div class="order-card">
    <p @onclick="ToggleCollapse" class="order-code fs-3">
        Order Code: @Order.OrderCode
    </p>
    <div class="order-collapse">
        <Collapse @ref="collapse">
            <p class="fs-2 fw-bold">@Order.CustomerName</p>
            <p class="fs-5 text-break">@Order.CustomerEmail</p>
            <p class="fs-5">Phone: @Order.CustomerPhone</p>
            <p class="fs-3">Order Details</p>
            <div class="order-detail-container">
                @foreach (var item in Order.OrderItems)
                {
                    <div class="order-detail-item-container">
                        <div class="order-detail-image">
                            <img src="@item.MenuItem.ImageUrl" alt="@item.MenuItem.Name" />
                        </div>
                        <div class="order-detail-item">
                            <p>@item.MenuItem.Name</p>
                            <p>Quantity: @item.Quantity</p>
                            @if (!string.IsNullOrWhiteSpace(item.Customization))
                            {
                                <p>Notes: @item.Customization</p>
                            }
                        </div>
                    </div>
                }
            </div>
            <p class="fs-3">Total amount: @Total.ToString("C")</p>
            <div>
                <p>Received: @FormatTimestamp(Order.ReceivedAt)</p>
                <p>Prep Start: @FormatTimestamp(Order.PreparingAt)</p>
                <p>Ready: @FormatTimestamp(Order.ReadyAt)</p>
                <p>Pickup: @FormatTimestamp(Order.CompletedAt)</p>
                <p>Canceled: @FormatTimestamp(Order.CanceledAt)</p>
            </div>
            <div class="order-status-container">
                @* <span class="fs-3">Status: </span> *@
                <button class="@GetStatusClass(OrderStatus.Received)" disabled="@IsStatusDisabled(OrderStatus.Received)" @onclick="AdvanceStatusAsync">Received</button>
                <button class="@GetStatusClass(OrderStatus.Preparing)" disabled="@IsStatusDisabled(OrderStatus.Preparing)" @onclick="AdvanceStatusAsync">Preparing</button>
                <button class="@GetStatusClass(OrderStatus.Ready)" disabled="@IsStatusDisabled(OrderStatus.Ready)" @onclick="AdvanceStatusAsync">Ready</button>
                <button class="@GetStatusClass(OrderStatus.Completed)" disabled="@IsStatusDisabled(OrderStatus.Completed)" @onclick="AdvanceStatusAsync">Completed</button>
                <button class="@GetStatusClass(OrderStatus.Canceled)" disabled="@IsStatusDisabled(OrderStatus.Canceled)" @onclick="AdvanceStatusAsync">Canceled</button>
            </div>
        </Collapse>
    </div>
    
    
</div>

@code {
    [Parameter]
    public Order Order {get; set;} = default!;

    [Parameter]
    public EventCallback<Order> OrderUpdated { get; set; }

    private Collapse collapse = default!;
    private bool isUpdating;

    private async Task ToggleCollapse() => await collapse.ToggleAsync();
    private decimal Total => Order.OrderItems.Sum(i => i.MenuItem.Price * i.Quantity);

    private string GetStatusClass(OrderStatus status)
    {
        var enabledStatus = GetEnabledStatus();
        return enabledStatus.HasValue && enabledStatus == status
            ? "button is-active"
            : "button";
    }

    private bool IsStatusDisabled(OrderStatus status)
    {
        if (isUpdating)
        {
            return true;
        }

        var enabledStatus = GetEnabledStatus();
        return !enabledStatus.HasValue || enabledStatus != status;
    }

    private OrderStatus? GetEnabledStatus() =>
        Order.Status switch
        {
            OrderStatus.Received => OrderStatus.Preparing,
            OrderStatus.Preparing => OrderStatus.Ready,
            OrderStatus.Ready => OrderStatus.Completed,
            _ => null
        };

    private async Task AdvanceStatusAsync()
    {
        if (isUpdating)
        {
            return;
        }

        var nextStatus = GetEnabledStatus();

        if (!nextStatus.HasValue)
        {
            return;
        }

        isUpdating = true;

        Order? orderToNotify = null;

        try
        {
            await using var context = await DbFactory.CreateDbContextAsync();
            var orderInDb = await context.Orders.FirstOrDefaultAsync(o => o.OrderId == Order.OrderId);

            if (orderInDb is not null)
            {
                if (orderInDb.Status == Order.Status)
                {
                    orderInDb.Status = nextStatus.Value;
                    await context.SaveChangesAsync();
                }

                ApplyOrderUpdates(orderInDb);
                orderToNotify = Order;
            }
        }
        finally
        {
            isUpdating = false;
        }

        if (orderToNotify is not null)
        {
            await InvokeAsync(StateHasChanged);
            await OrderUpdated.InvokeAsync(orderToNotify);
        }
    }

    private void ApplyOrderUpdates(Order source)
    {
        Order.Status = source.Status;
        Order.ReceivedAt = source.ReceivedAt;
        Order.PreparingAt = source.PreparingAt;
        Order.ReadyAt = source.ReadyAt;
        Order.CompletedAt = source.CompletedAt;
        Order.CanceledAt = source.CanceledAt;
    }

    private static string FormatTimestamp(DateTime? timestamp)
    {
        if (timestamp is not DateTime value)
        {
            return "â€”";
        }

        return value.ToLocalTime().ToString("MMM d, yyyy h:mm tt");
    }
}
